
# self-injector
Reverse task for newbies with anti-debugging techniques.

## Описание программы
Программа запрашивает у пользователя на ввод предварительно зашифрованный флаг и ключ для его расшифрования.
Оба этих файла известны пользователю, при запуске программа выгружает их в текущую рабочую папку. 
После введения ключа и флага, программа расшифровывает флаг и выводит его на экран.

## Особенность задания
При запуске программа в первую очередь внедряет в себя dll-библиотеку, которая (при помощи библиотеки Microsoft Detours) перехватывает вызов системной функции расшифрования, заменяя ее на бесполезную альтернативу, отчего пользователю выводится его же зашифрованный флаг.

## Cредства антиотладки

### Обфускация системных вызовов
За обфускацию системных вызовов отвечает модуль `obfuscate_calls`. 
Структура данных `PRESOLVE_ENTRY`, состоющая из полей - хеш имени функции, имя системной библиотеки, в таблице экспорта которой находится эта функция, адресс функции внутри памяти библиотеки - представлена глобальным объектом `rtSysCallsTable`. Фукция `resolve_init` производит динамический поиск имен конкретных функции в таблице `rtSysCallsTable` и заполняет поле указателей на эти функции в памяти указанной системной dll библиотеки. Найденные адреса присваиваются глобальным, принадлежащим этому исполняемому файлу, прототипам указателей на функции, которые описаны в `obfuscate_calls.h`.
Далее глобальные указатели на функции используются вместо обычных, это усложняет статический анализ (теперь предполагать о работе функиций можно только по сигнатуре функции и аргументам).
Пример того, как ida-hexrays распознает такой вызов:
```c
// Вызов функции CreateFile 
//dll_handle = CreateFile(injecting_dll_name, generic_write, 0, 0, CREATE_ALWAYS, FILE_ATTRIBUTE_HIDDEN, 0);
v39 = dword_40E75C(v2, v3, 0, 0, 2, 2, 0);
```

### Compile-time обфускация строк
За обфускацию строк времени компиляции отвечает макрос `cptime_obf(data)` описанный в header-only библиотеке `obfuscate_strings.h`. Шаблонный класс `obfuscator` отвечает за compile-time обфускацию. Он принимает в качестве параметров шаблона  длину строки и однобайтовый ключ, с которым строка будет ксориться.
Класс `obfuscated_data` отвечает за runtime расшифрование обфусцированной на этапе компиляции строки.
Макрос `cptime_obf` является алиасом на макрос `cptime_obf_key(data,'f')`.
> В программе намеренно используется макрос `cptime_obf`, так все строки будут зашифрованы на одинаковый однобайтовый ключ.

Зашифрование происходит путем подстановки объекта класса `obfuscated_data` на место используемой строки, а runtime-расшифрование путем перегрузки оператора приведение типа.
> Так, при передаче этого объекта в функцию, принимающую `char*`, вызовется перегрузка объекта класса, которая в свою очередь вызывает функцию `decrypt`, расшифровывающую текущую строку и отдающую ее в чисто виде в функцию.

## Этапы укорочения решение задания
* Если из памяти программы просто выпилить внедряемую ей же dll, то программа вернет верный флаг т.к. успешно его расшифрует.
* Если заметить, что функция инжектирования вызывается только после заведомо верной проверки (небольшой пример branch floatering'a) и запатчить переменную, куда записывается результат, функция не вызовется и флаг так же расшифруется пользователю успешно.


## Сборка
Собирать проект стоит в конфигурации Debug/Release x86 с помощью Visual Studio (toolset v142).
> Бесплатная версия microsoft detours поддерживает только программы x86.

Для упрощения исследования программы рекомендуется выбрать пункты в меню проекта:
* С/C++ -> Оптимизация ->
	* Оптимизация = Отключено
	* Развертывание подставляемых функций = Отключено
	* Предпочитать размер или скорость = Предпочитать краткость кода
	* Оптимизация всей программы = Нет
* С/C++ -> Создание кода ->
	* Включить компановку на уровне функци = Нет